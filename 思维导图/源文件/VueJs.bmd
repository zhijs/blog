<?xml version="1.0" encoding="utf-8"?>
<map name="VueJs" document_type="Blumind" editor_version="1.3.16.0">
  <!--Create by Blumind, you can download it free from http://www.blumind.org/download-->
  <info />
  <layout>MIND_MAP</layout>
  <attributes>
    <item name="editor_show_sidebar">True</item>
  </attributes>
  <style>
    <back_color>White</back_color>
    <fore_color>Black</fore_color>
    <line_color>LightSlateGray</line_color>
    <border_color>SlateGray</border_color>
    <node_back_color>LightGray</node_back_color>
    <node_fore_color>Black</node_fore_color>
    <select_color>RoyalBlue</select_color>
    <hover_color>MediumSlateBlue</hover_color>
    <link_line_color>Green</link_line_color>
  </style>
  <nodes>
    <node text="VueJs">
      <style>
        <back_color>Lime</back_color>
        <fore_color>Black</fore_color>
        <border_color>Black</border_color>
        <padding>12</padding>
      </style>
      <nodes>
        <node text="2.x 版本">
          <nodes>
            <node text="响应式原理">
              <nodes>
                <node text="普通对象">
                  <nodes>
                    <node text="Object.definePropert">
                      <nodes>
                        <node text="每个 data 属性都&#xD;&#xA;通过闭包引用一个 Dep" />
                        <node text="Dep 里面存放依赖该属性的 Watcher在依赖收集的时候&#xD;&#xA;渲染 Watcher 会被被放入到 Dep 数组中" />
                        <node text="set 的时候取出 Dep 里面的 Watcher&#xD;&#xA;将 Watcher 放入等待队列中等待执行" />
                      </nodes>
                    </node>
                  </nodes>
                </node>
                <node text="数组对象">
                  <nodes>
                    <node text="劫持 7 个方法">
                      <nodes>
                        <node text="push" />
                        <node text="pop" />
                        <node text="shift" />
                        <node text="unshift" />
                        <node text="splice" />
                        <node text="sort" />
                        <node text="reverse" />
                      </nodes>
                    </node>
                    <node text="即是下列操作不是响应式的&#xD;&#xA;--------------------------------&#xD;&#xA;data.arr[0] = newValue&#xD;&#xA;---------------------------------&#xD;&#xA;data.arr.length = n" />
                  </nodes>
                </node>
              </nodes>
            </node>
            <node text="virtual dom">
              <nodes>
                <node text="相比原生 dom 操作优势">
                  <nodes>
                    <node text="没有任何框架可以比纯手动的优化 DOM 操作更快&#xD;&#xA;因为框架的 DOM 操作层需要应对任何&#xD;&#xA;上层 API 可能产生的操作，它的实现必须是普适的" />
                    <node text="性能  vs 可维护性的取舍">
                      <nodes>
                        <node text="1. 掩盖底层的 DOM 操作，让你用更声明式的&#xD;&#xA;方式来描述你的目的，从而让你的代码更容易维护" />
                        <node text="2. 可以跨平台支持，比如 ReactNative" />
                        <node text="3. 提升开发效率" />
                      </nodes>
                    </node>
                  </nodes>
                </node>
                <node text="JS模拟的DOM结构，将 DOM 变化的对比放在 JS 层来做">
                  <nodes>
                    <node text="纯 js 层面的计算，比 DOM 操作来说&#xD;&#xA;便宜了太多">
                      <nodes>
                        <node text="保证了不管你的数据变化多少&#xD;&#xA;每次重绘的性能都可以接受" />
                      </nodes>
                    </node>
                  </nodes>
                </node>
              </nodes>
            </node>
            <node text="diff 算法">
              <nodes>
                <node text="前提">
                  <nodes>
                    <node text="同层比较">
                      <nodes>
                        <node text="web UI中跨级移动操作非常少&#xD;&#xA;可以忽略不计" />
                      </nodes>
                    </node>
                    <node text="相同类型的两个组件产生的 DOM 结构是类似的" />
                    <node text="对于同一层级的一组子节点，分配唯一 id 区分 (key)" />
                  </nodes>
                </node>
              </nodes>
            </node>
            <node text="异步更新队列">
              <nodes>
                <node text="data 更新的时候都会&#xD;&#xA;将 watcher 放到异步队列中" />
                <node text="到下一个事件循环才&#xD;&#xA;执行去重队列中的 watcher.update" />
                <node text="下一循环 tick 优先级">
                  <nodes>
                    <node text="1. Promise.then" />
                    <node text="2. MutationObserver" />
                    <node text="3. setImmediate" />
                    <node text="4. setTimeout(fn, 0)" />
                  </nodes>
                </node>
              </nodes>
            </node>
            <node text="key 的作用">
              <nodes>
                <node text="index 作为 Key 和  id 作为 key 的区别 ">
                  <nodes>
                    <node text="以实际场景出发，index 作为 key, 或者 key 为 undefined 时候&#xD;&#xA;假设在列表第一个插入一个元素，则会导致所有的列表&#xD;&#xA;都重新更新，无法复用&#xD;&#xA;------------------------------------------------------------&#xD;&#xA;或者排序的时候会出现问题，DOM 会被直接更新而不是移动" />
                  </nodes>
                </node>
                <node text="没有 key 的情况下默认为 undefined" />
                <node text="复用元素，减少不必要的更新" />
              </nodes>
            </node>
            <node text="wacher 和 computed">
              <nodes>
                <node text="区别" />
              </nodes>
            </node>
            <node text="v-model 原理">
              <nodes>
                <node text="v-bind:value=&quot;value&quot;" />
                <node text="type=&quot;text&quot;&#xD;&#xA;type=&quot;textare&quot;">
                  <nodes>
                    <node text="监听 input 事件并更新值&#xD;&#xA;-------------------------------------------&#xD;&#xA;@input=&quot;value = $event.target.value&quot;" />
                  </nodes>
                </node>
                <node text="type=&quot;checkbox&quot;&#xD;&#xA;type=&quot;radio&quot;">
                  <nodes>
                    <node text="监听 change 事件并更新值&#xD;&#xA;-------------------------------------------&#xD;&#xA;@change=&quot;value = $event.target.value&quot;" />
                  </nodes>
                </node>
              </nodes>
            </node>
            <node text="Dep" />
            <node text="Watcher" />
          </nodes>
        </node>
        <node text="3.0 版本" />
      </nodes>
    </node>
  </nodes>
</map>